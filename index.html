<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Battle for NFT</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    body {
      margin: 0;
      padding: 15px;
      font-family: 'Courier New', monospace;
      background: #0f0e17;
      color: #e0d6af;
      background-image: url('assets/backgrounds/world_map.jpg');
      background-size: cover;
    }
    .container {
      max-width: 600px;
      margin: 0 auto;
      background: rgba(15, 14, 23, 0.85);
      padding: 20px;
      border: 1px solid #7a6545;
    }
    h2, h3 {
      color: #c9a763;
      text-align: center;
    }
    button {
      background: #2c1a1a;
      color: #ffd700;
      border: 1px solid #8b6f3a;
      padding: 10px;
      margin: 6px 0;
      width: 100%;
    }
    .stats {
      background: rgba(0,0,0,0.6);
      padding: 12px;
      margin: 15px 0;
    }
    #map-container {
      position: relative;
      height: 300px;
      margin: 20px 0;
      background: url('assets/backgrounds/world_map.jpg');
      background-size: 100% 100%;
    }
    #player-token {
      position: absolute;
      width: 40px;
      height: 40px;
      background: #ffd700;
      border-radius: 50%;
      transition: all 0.5s ease;
    }
    #battle-ui, #tournament-ui, #quests-ui, #forge-ui, #altar-ui { display: none; }
    .zone-btn { width: 30%; display: inline-block; margin: 2px; }
  </style>
</head>
<body>
  <div class="container">
    <h2>‚öîÔ∏è Battle for NFT</h2>
    <div id="player-info" class="stats">Loading...</div>

    <div id="map-container">
      <div id="player-token"></div>
    </div>

    <button onclick="moveTo('tavern')">Tavern</button>
    <button onclick="moveTo('arena')">Arena</button>
    <button onclick="moveTo('forge')">Forge</button>
    <button onclick="moveTo('mage_tower')">Mage Tower</button>
    <button onclick="moveTo('altar')">Altar</button>
    <button onclick="showQuests()">Quests</button>
    <button onclick="checkTournament()">Tournaments</button>
  </div>

  <!-- Altar UI -->
  <div id="altar-ui" class="container">
    <h3>NFT Sacrifice Altar</h3>
    <p>To receive blessings, send any Telegram Gift to this bot.</p>
    <p>After sending a gift, click the button below:</p>
    <button onclick="simulateNFTSacrifice()">I sent a gift!</button>
    <p>NFT Sacrifices: <span id="nft-count">0</span></p>
    <button onclick="closeAltarUI()">Close</button>
  </div>

  <!-- Forge UI -->
  <div id="forge-ui" class="container">
    <h3>Blacksmith Forge</h3>
    <div id="forge-items"></div>
    <button onclick="closeForgeUI()">Close</button>
  </div>

  <!-- Quests UI -->
  <div id="quests-ui" class="container">
    <h3>Available Quests</h3>
    <div id="quests-list"></div>
    <button onclick="closeQuestsUI()">Close</button>
  </div>

  <!-- Tournament UI -->
  <div id="tournament-ui" class="container">
    <h3>Tournament Registration</h3>
    <div id="tournament-info"></div>
    <button onclick="registerForTournament('tavern')">Register for Tavern Tournament</button>
    <button onclick="registerForTournament('arena')">Register for Arena Tournament</button>
    <button onclick="viewTournamentMatches()">View Matches</button>
    <button onclick="closeTournamentUI()">Close</button>
  </div>

  <!-- Battle UI -->
  <div id="battle-ui" class="container">
    <h3>Battle Round - 60s</h3>
    <div>Attack zone:</div>
    <button class="zone-btn" onclick="setAttackZone('head')">Head</button>
    <button class="zone-btn" onclick="setAttackZone('body')">Body</button>
    <button class="zone-btn" onclick="setAttackZone('legs')">Legs</button>
    
    <div>Defense zone:</div>
    <button class="zone-btn" onclick="setDefenseZone('head')">Head</button>
    <button class="zone-btn" onclick="setDefenseZone('body')">Body</button>
    <button class="zone-btn" onclick="setDefenseZone('legs')">Legs</button>
    
    <div>Spells (cooldown: 2 turns):</div>
    <button onclick="castSpell('firebolt')">Fire Bolt</button>
    <button onclick="castSpell('ice_shard')">Ice Shard</button>
    <button onclick="castSpell('heal')">Heal</button>
    <button onclick="castSpell('teleport')">Teleport</button>
    
    <button onclick="submitBattleAction()">Submit Action</button>
    <button onclick="endBattle()">Flee</button>
  </div>

  <script>
    const tg = window.Telegram.WebApp;
    tg.expand();
    const user = tg.initDataUnsafe?.user;

    if (!user) {
      document.body.innerHTML = "<h2 style='color:white;text-align:center;'>Open via Telegram!</h2>";
      throw new Error("No Telegram context");
    }

    // === YOUR TELEGRAM DATA ===
    const YOUR_TELEGRAM_ID = 7454538673;

    // === LOCATIONS COORDINATES ===
    const LOCATIONS = {
      tavern: { x: 100, y: 150 },
      arena: { x: 400, y: 100 },
      forge: { x: 200, y: 250 },
      mage_tower: { x: 300, y: 200 },
      altar: { x: 500, y: 250 },
      cave: { x: 150, y: 100 },
      swamp: { x: 450, y: 200 },
      forest: { x: 250, y: 150 }
    };

    // === WEAPONS WITH FULL PARAMETERS ===
    const WEAPONS = {
      dagger: { 
        name: "Dagger", 
        minDmg: 1, 
        maxDmg: 3, 
        crit: 15, 
        type: "onehand",
        upgrades: 0,
        maxUpgrades: 3,
        upgradeCost: { diamonds: 10, resource: "iron_ore" }
      },
      sword: { 
        name: "Sword", 
        minDmg: 2, 
        maxDmg: 4, 
        crit: 5, 
        type: "onehand",
        upgrades: 0,
        maxUpgrades: 3,
        upgradeCost: { diamonds: 15, resource: "iron_ore" }
      },
      axe: { 
        name: "Axe", 
        minDmg: 3, 
        maxDmg: 5, 
        crit: 8, 
        type: "onehand",
        upgrades: 0,
        maxUpgrades: 3,
        upgradeCost: { diamonds: 12, resource: "iron_ore" }
      },
      greatsword: { 
        name: "Greatsword", 
        minDmg: 6, 
        maxDmg: 10, 
        crit: 10, 
        type: "twohand",
        upgrades: 0,
        maxUpgrades: 3,
        upgradeCost: { diamonds: 25, resource: "iron_ore" }
      },
      warhammer: { 
        name: "Warhammer", 
        minDmg: 7, 
        maxDmg: 11, 
        crit: 5, 
        type: "twohand",
        upgrades: 0,
        maxUpgrades: 3,
        upgradeCost: { diamonds: 20, resource: "iron_ore" }
      },
      staff_fire: { 
        name: "Fire Staff", 
        minDmg: 1, 
        maxDmg: 2, 
        crit: 2, 
        type: "staff", 
        school: "fire", 
        manaBonus: 5,
        upgrades: 0,
        maxUpgrades: 2,
        upgradeCost: { diamonds: 18, resource: "swamp_herb" }
      },
      staff_ice: { 
        name: "Ice Staff", 
        minDmg: 1, 
        maxDmg: 2, 
        crit: 2, 
        type: "staff", 
        school: "ice", 
        manaBonus: 5,
        upgrades: 0,
        maxUpgrades: 2,
        upgradeCost: { diamonds: 18, resource: "swamp_herb" }
      },
      staff_death: { 
        name: "Death Staff", 
        minDmg: 1, 
        maxDmg: 2, 
        crit: 2, 
        type: "staff", 
        school: "death", 
        manaBonus: 5,
        upgrades: 0,
        maxUpgrades: 2,
        upgradeCost: { diamonds: 18, resource: "bone" }
      },
      staff_life: { 
        name: "Life Staff", 
        minDmg: 1, 
        maxDmg: 2, 
        crit: 2, 
        type: "staff", 
        school: "life", 
        manaBonus: 5,
        upgrades: 0,
        maxUpgrades: 2,
        upgradeCost: { diamonds: 18, resource: "bandit_medallion" }
      }
    };

    // === SHIELDS ===
    const SHIELDS = {
      wooden_shield: { 
        name: "Wooden Shield", 
        blockMin: 10, 
        blockMax: 30, 
        reduceMin: 10, 
        reduceMax: 30,
        upgrades: 0,
        maxUpgrades: 2,
        upgradeCost: { diamonds: 8, resource: "wood" }
      },
      leather_shield: { 
        name: "Leather Shield", 
        blockMin: 20, 
        blockMax: 40, 
        reduceMin: 20, 
        reduceMax: 40,
        upgrades: 0,
        maxUpgrades: 2,
        upgradeCost: { diamonds: 12, resource: "leather" }
      },
      metal_shield: { 
        name: "Metal Shield", 
        blockMin: 30, 
        blockMax: 50, 
        reduceMin: 30, 
        reduceMax: 50,
        upgrades: 0,
        maxUpgrades: 2,
        upgradeCost: { diamonds: 20, resource: "iron_ore" }
      }
    };

    // === QUESTS SYSTEM ===
    const QUESTS = {
      cave_skeletons: {
        id: "cave_skeletons",
        name: "Skeleton Cave",
        description: "Defeat 5 Skeleton Warriors in the cave",
        target: "skeleton",
        location: "cave",
        count: 5,
        current: 0,
        completed: false,
        reward: { diamonds: 5, gold: 50, resources: { bone: 5 } }
      },
      swamp_goblins: {
        id: "swamp_goblins",
        name: "Swamp Goblins",
        description: "Eliminate 8 Goblins in the swamp",
        target: "goblin",
        location: "swamp",
        count: 8,
        current: 0,
        completed: false,
        reward: { diamonds: 10, gold: 80, resources: { goblin_ear: 8 } }
      },
      forest_bandits: {
        id: "forest_bandits",
        name: "Forest Bandits",
        description: "Clear 10 Bandits from the forest",
        target: "bandit",
        location: "forest",
        count: 10,
        current: 0,
        completed: false,
        reward: { diamonds: 15, gold: 120, resources: { bandit_medallion: 10 } }
      }
    };

    // === SPELLS WITH LEVEL REQUIREMENTS ===
    const SPELLS = {
      fire: [
        { id: "firebolt", name: "Fire Bolt", damage: 8, mana: 3, cooldown: 2, effect: "burn", effectDamage: 2, effectDuration: 2, levelReq: 5 },
        { id: "fireball", name: "Fireball", damage: 12, mana: 5, cooldown: 2, effect: "burn", effectDamage: 3, effectDuration: 3, levelReq: 15 }
      ],
      ice: [
        { id: "ice_shard", name: "Ice Shard", damage: 6, mana: 3, cooldown: 2, effect: "freeze", effectDamage: 1, effectDuration: 2, levelReq: 5 },
        { id: "frost_nova", name: "Frost Nova", damage: 10, mana: 5, cooldown: 2, effect: "freeze", effectDamage: 2, effectDuration: 3, levelReq: 15 }
      ],
      death: [
        { id: "shadow_bolt", name: "Shadow Bolt", damage: 7, mana: 3, cooldown: 2, levelReq: 5 },
        { id: "mana_drain", name: "Mana Drain", mana: 4, cooldown: 2, levelReq: 10,
          effect: function(player, target) {
            const healAmt = Math.floor(player.max_mana * 0.25);
            const cost = Math.floor(player.max_hp * 0.1);
            player.mana = Math.min(player.max_mana, player.mana + healAmt);
            player.hp = Math.max(1, player.hp - cost);
          }
        }
      ],
      life: [
        { id: "heal", name: "Heal", mana: 3, cooldown: 2, levelReq: 5,
          effect: function(player) {
            const healAmt = Math.floor(player.max_hp * 0.2);
            player.hp = Math.min(player.max_hp, player.hp + healAmt);
          }
        },
        { id: "teleport", name: "Teleport to Tavern", mana: 4, cooldown: 2, levelReq: 10,
          effect: function() {
            alert("Teleported to Tavern!");
            endBattle();
          }
        }
      ]
    };

    // === MONSTER TEMPLATES WITH DROPS ===
    const MONSTER_TEMPLATES = {
      skeleton: {
        name: "Skeleton Warrior",
        baseLevel: 1,
        stats: { strength: 2, agility: 1, stamina: 2, intellect: 0 },
        spells: [],
        drops: { bone: 1 }
      },
      goblin: {
        name: "Goblin",
        baseLevel: 2,
        stats: { strength: 3, agility: 3, stamina: 2, intellect: 1 },
        spells: [],
        drops: { goblin_ear: 1 }
      },
      wolf: {
        name: "Dire Wolf",
        baseLevel: 3,
        stats: { strength: 4, agility: 4, stamina: 3, intellect: 0 },
        spells: [],
        drops: { wolf_pelt: 1 }
      },
      bear: {
        name: "Grizzly Bear",
        baseLevel: 5,
        stats: { strength: 6, agility: 2, stamina: 5, intellect: 0 },
        spells: [],
        drops: { bear_claw: 1 }
      },
      swamp_witch: {
        name: "Swamp Witch",
        baseLevel: 4,
        stats: { strength: 2, agility: 2, stamina: 3, intellect: 5 },
        spells: ["ice_shard", "shadow_bolt"],
        drops: { swamp_herb: 2 }
      },
      bandit: {
        name: "Bandit",
        baseLevel: 3,
        stats: { strength: 3, agility: 3, stamina: 3, intellect: 2 },
        spells: [],
        drops: { bandit_medallion: 1 }
      }
    };

    function createMonster(type, level) {
      const template = MONSTER_TEMPLATES[type];
      const stats = { ...template.stats };
      
      const levelDiff = level - template.baseLevel;
      if (levelDiff > 0) {
        stats.strength += levelDiff;
        stats.agility += levelDiff;
        stats.stamina += levelDiff;
        stats.intellect += levelDiff;
      }
      
      return {
        name: `${template.name} Lvl ${level}`,
        level: level,
        strength: stats.strength,
        agility: stats.agility,
        stamina: stats.stamina,
        intellect: stats.intellect,
        hp: 10 + stats.stamina * 2,
        max_hp: 10 + stats.stamina * 2,
        damage: 2 + stats.strength,
        armor: stats.stamina,
        mana: stats.intellect,
        max_mana: stats.intellect,
        drops: template.drops,
        spells: template.spells
      };
    }

    // === PLAYER CREATION WITH FULL DATA ===
    function createPlayer() {
      const gender = (user.id % 2 === 0) ? "female" : "male";
      
      return {
        id: user.id,
        name: user.first_name || "Adventurer",
        gender: gender,
        level: 1,
        exp: 0,
        strength: 0,
        agility: 0,
        stamina: 0,
        intellect: 0,
        energy: 10,
        max_energy: 10,
        hp: 10,
        max_hp: 10,
        mana: 0,
        max_mana: 0,
        diamonds: 0,
        gold: 0,
        inventory: {
          mainHand: null,
          offHand: null
        },
        resources: {
          bone: 0,
          goblin_ear: 0,
          iron_ore: 0,
          swamp_herb: 0,
          bandit_medallion: 0,
          wolf_pelt: 0,
          bear_claw: 0,
          wood: 0,
          leather: 0
        },
        magicSchool: null,
        spellCooldowns: {},
        battleEffects: {},
        quests: JSON.parse(JSON.stringify(QUESTS)),
        nftSacrifices: 0,
        currentLocation: "world_map"
      };
    }

    let player;

    // === LOCAL STORAGE FUNCTIONS ===
    function loadFromLocalStorage() {
      const saved = localStorage.getItem(`player_${user.id}`);
      if (saved) {
        return JSON.parse(saved);
      }
      return null;
    }

    function saveToLocalStorage() {
      localStorage.setItem(`player_${user.id}`, JSON.stringify(player));
      render();
    }

    // === INITIALIZATION ===
    function initGame() {
      const savedPlayer = loadFromLocalStorage();
      if (savedPlayer) {
        player = savedPlayer;
      } else {
        player = createPlayer();
        // Special tester mode for your ID
        if (user.id === YOUR_TELEGRAM_ID) {
          player.level = 50;
          player.exp = 9999999;
          player.strength = 25;
          player.agility = 25;
          player.stamina = 25;
          player.intellect = 25;
          player.diamonds = 10000;
          player.inventory.mainHand = "greatsword";
          player.inventory.offHand = "metal_shield";
          player.magicSchool = "fire";
          player.nftSacrifices = 10;
        }
        saveToLocalStorage();
      }
      render();
      updateQuestsUI();
    }

    // === ALTAR SYSTEM (SIMULATED) ===
    function simulateNFTSacrifice() {
      player.nftSacrifices++;
      
      // Random blessing
      const blessings = ["+1% EXP", "+1% HP", "+1 Energy", "+1 Mana"];
      const blessing = blessings[Math.floor(Math.random() * blessings.length)];
      
      alert(`üôè NFT Sacrifice Accepted!\nYou received: ${blessing}`);
      
      saveToLocalStorage();
      document.getElementById('nft-count').textContent = player.nftSacrifices;
    }

    function showAltarUI() {
      document.getElementById('altar-ui').style.display = 'block';
      document.getElementById('nft-count').textContent = player.nftSacrifices;
    }

    function closeAltarUI() {
      document.getElementById('altar-ui').style.display = 'none';
    }

    // === LOCATION SYSTEM ===
    function moveTo(location) {
      // Handle death state
      if (player.hp <= 0) {
        player.hp = player.max_hp;
        player.mana = player.max_mana;
        alert("Revived in Tavern!");
        location = 'tavern';
      }
      
      const token = document.getElementById('player-token');
      const coords = LOCATIONS[location] || { x: 300, y: 150 };
      
      token.style.left = coords.x + 'px';
      token.style.top = coords.y + 'px';
      player.currentLocation = location;
      
      // Location-specific actions
      if (location === 'tavern') {
        // Auto-remove non-staff weapons in tavern
        if (player.inventory.mainHand && WEAPONS[player.inventory.mainHand]?.type !== 'staff') {
          alert("Weapons not allowed in Tavern! Switching to bare hands.");
          player.inventory.mainHand = null;
        }
      } else if (location === 'forge') {
        showForgeUI();
      } else if (location === 'altar') {
        showAltarUI();
      } else if (location === 'cave' || location === 'swamp' || location === 'forest') {
        // Auto-start quest battles
        const questKey = Object.keys(QUESTS).find(key => QUESTS[key].location === location);
        if (questKey && !player.quests[questKey].completed) {
          startBattle(QUESTS[questKey].target, Math.floor(Math.random() * 3) + 1);
        }
      }
      
      saveToLocalStorage();
    }

    // === FORGE SYSTEM ===
    function showForgeUI() {
      document.getElementById('forge-ui').style.display = 'block';
      let html = "<h4>Upgrade Items:</h4>";
      
      if (player.inventory.mainHand) {
        const item = WEAPONS[player.inventory.mainHand];
        if (item.upgrades < item.maxUpgrades) {
          html += `<div>${item.name} (Lvl ${item.upgrades})<br>
                   Cost: ${item.upgradeCost.diamonds} üíé + ${item.upgradeCost.resource}<br>
                   <button onclick="upgradeItem('mainHand')">Upgrade</button></div>`;
        }
      }
      
      if (player.inventory.offHand && SHIELDS[player.inventory.offHand]) {
        const item = SHIELDS[player.inventory.offHand];
        if (item.upgrades < item.maxUpgrades) {
          html += `<div>${item.name} (Lvl ${item.upgrades})<br>
                   Cost: ${item.upgradeCost.diamonds} üíé + ${item.upgradeCost.resource}<br>
                   <button onclick="upgradeItem('offHand')">Upgrade</button></div>`;
        }
      }
      
      document.getElementById('forge-items').innerHTML = html;
    }

    function closeForgeUI() {
      document.getElementById('forge-ui').style.display = 'none';
    }

    function upgradeItem(slot) {
      let item;
      
      if (slot === 'mainHand') {
        item = WEAPONS[player.inventory.mainHand];
      } else if (slot === 'offHand' && SHIELDS[player.inventory.offHand]) {
        item = SHIELDS[player.inventory.offHand];
      }
      
      if (item && item.upgrades < item.maxUpgrades) {
        const cost = item.upgradeCost;
        if (player.diamonds >= cost.diamonds && player.resources[cost.resource] >= 1) {
          player.diamonds -= cost.diamonds;
          player.resources[cost.resource]--;
          item.upgrades++;
          
          // Random bonus on upgrade
          const bonusTypes = ['minDmg', 'maxDmg', 'crit', 'blockMin', 'blockMax'];
          const randomBonus = bonusTypes[Math.floor(Math.random() * bonusTypes.length)];
          const bonusAmount = Math.floor(Math.random() * 3) + 1;
          item[randomBonus] = (item[randomBonus] || 0) + bonusAmount;
          
          alert(`Item upgraded! +${bonusAmount} to ${randomBonus}`);
          saveToLocalStorage();
          showForgeUI();
        } else {
          alert("Not enough resources!");
        }
      }
    }

    // === QUESTS SYSTEM ===
    function showQuests() {
      document.getElementById('quests-ui').style.display = 'block';
      updateQuestsUI();
    }

    function closeQuestsUI() {
      document.getElementById('quests-ui').style.display = 'none';
    }

    function updateQuestsUI() {
      let html = "";
      for (const [id, quest] of Object.entries(player.quests)) {
        if (!quest.completed) {
          const progress = Math.min(100, Math.floor((quest.current / quest.count) * 100));
          html += `
            <div style="border:1px solid #7a6545; padding:10px; margin:5px 0;">
              <strong>${quest.name}</strong><br>
              ${quest.description}<br>
              Location: ${quest.location}<br>
              Progress: ${quest.current}/${quest.count} (${progress}%)<br>
              ${quest.current >= quest.count ? '<button onclick="completeQuest(\'' + id + '\')">Complete</button>' : ''}
            </div>
          `;
        }
      }
      document.getElementById('quests-list').innerHTML = html;
    }

    function completeQuest(questId) {
      const quest = player.quests[questId];
      if (quest.current >= quest.count && !quest.completed) {
        quest.completed = true;
        player.diamonds += quest.reward.diamonds;
        player.gold += quest.reward.gold;
        for (const [res, amount] of Object.entries(quest.reward.resources || {})) {
          player.resources[res] = (player.resources[res] || 0) + amount;
        }
        alert(`Quest completed! Reward: ${quest.reward.diamonds} üíé, ${quest.reward.gold} gold`);
        saveToLocalStorage();
        updateQuestsUI();
        render();
      }
    }

    // === BATTLE SYSTEM ===
    let currentBattle = null;
    let battleTimer = null;

    function startBattle(monsterType = null, monsterLevel = null) {
      if (!monsterType) {
        monsterType = Object.keys(MONSTER_TEMPLATES)[Math.floor(Math.random() * Object.keys(MONSTER_TEMPLATES).length)];
      }
      if (!monsterLevel) {
        monsterLevel = Math.floor(Math.random() * 3) + 1;
      }
      
      currentBattle = {
        monster: createMonster(monsterType, monsterLevel),
        playerAction: null,
        monsterAction: null,
        round: 1,
        playerEffects: {},
        monsterEffects: {}
      };
      
      document.getElementById('battle-ui').style.display = 'block';
      startBattleTimer();
    }

    function startBattleTimer() {
      let timeLeft = 60;
      document.getElementById('battle-ui').querySelector('h3').textContent = `Battle Round ${currentBattle.round} - ${timeLeft}s`;
      
      battleTimer = setInterval(() => {
        timeLeft--;
        document.getElementById('battle-ui').querySelector('h3').textContent = `Battle Round ${currentBattle.round} - ${timeLeft}s`;
        
        if (timeLeft <= 0) {
          clearInterval(battleTimer);
          autoSubmitAction();
        }
      }, 1000);
    }

    function setAttackZone(zone) {
      if (!currentBattle) return;
      currentBattle.playerAction = currentBattle.playerAction || {};
      currentBattle.playerAction.attack = zone;
    }

    function setDefenseZone(zone) {
      if (!currentBattle) return;
      currentBattle.playerAction = currentBattle.playerAction || {};
      currentBattle.playerAction.defense = zone;
    }

    function castSpell(spellId) {
      if (!currentBattle) return;
      
      // Check spell level requirement
      let spellFound = null;
      for (const school of Object.values(SPELLS)) {
        for (const spell of school) {
          if (spell.id === spellId) {
            spellFound = spell;
            break;
          }
        }
        if (spellFound) break;
      }
      
      if (spellFound && player.level < spellFound.levelReq) {
        alert(`Requires level ${spellFound.levelReq}!`);
        return;
      }
      
      if (player.spellCooldowns[spellId] > 0) {
        alert(`${spellId} on cooldown!`);
        return;
      }
      
      if (player.mana < (spellFound.mana || 0)) {
        alert("Not enough mana!");
        return;
      }
      
      currentBattle.playerAction = currentBattle.playerAction || {};
      currentBattle.playerAction.spell = spellId;
      player.spellCooldowns[spellId] = 2;
    }

    function autoSubmitAction() {
      if (!currentBattle.playerAction) {
        currentBattle.playerAction = {
          attack: ['head', 'body', 'legs'][Math.floor(Math.random() * 3)],
          defense: ['head', 'body', 'legs'][Math.floor(Math.random() * 3)]
        };
      }
      resolveBattleRound();
    }

    function submitBattleAction() {
      if (!currentBattle.playerAction) {
        alert("Choose action!");
        return;
      }
      clearInterval(battleTimer);
      resolveBattleRound();
    }

    function calculateStats(entity) {
      let totalMinDmg = 0, totalMaxDmg = 0, totalCrit = 0;
      let canBlock = false, blockMin = 0, blockMax = 0, reduceMin = 0, reduceMax = 0;
      let manaBonus = 0, magicSchool = null;

      if (entity.inventory?.mainHand) {
        const w = WEAPONS[entity.inventory.mainHand];
        if (w) {
          totalMinDmg += w.minDmg;
          totalMaxDmg += w.maxDmg;
          totalCrit += w.crit;
          if (w.type === "staff") {
            manaBonus += w.manaBonus;
            magicSchool = w.school;
          }
        }
      }

      if (entity.inventory?.offHand) {
        if (SHIELDS[entity.inventory.offHand]) {
          const s = SHIELDS[entity.inventory.offHand];
          canBlock = true;
          blockMin = s.blockMin;
          blockMax = s.blockMax;
          reduceMin = s.reduceMin;
          reduceMax = s.reduceMax;
        } else if (WEAPONS[entity.inventory.offHand]?.type === "onehand") {
          const offW = WEAPONS[entity.inventory.offHand];
          // Dual wield only with daggers
          if (offW.name === "Dagger" || 
              (WEAPONS[entity.inventory.mainHand]?.name === "Dagger" && offW.name === "Dagger")) {
            totalMinDmg += offW.minDmg;
            totalMaxDmg += offW.maxDmg;
            totalCrit += offW.crit;
            if (canBlock) {
              blockMin = Math.max(0, blockMin - 10);
              blockMax = Math.max(0, blockMax - 10);
            }
          }
        }
      }

      if (entity.inventory?.mainHand && WEAPONS[entity.inventory.mainHand]?.type === "twohand") {
        canBlock = false;
        blockMin = blockMax = reduceMin = reduceMax = 0;
      }

      return { totalMinDmg, totalMaxDmg, totalCrit, canBlock, blockMin, blockMax, reduceMin, reduceMax, manaBonus, magicSchool };
    }

    function calculateDamage(baseMin, baseMax, critChance) {
      const baseDmg = Math.floor(Math.random() * (baseMax - baseMin + 1)) + baseMin;
      const isCrit = Math.random() * 100 < critChance;
      return isCrit ? Math.floor(baseDmg * 1.5) : baseDmg;
    }

    function applyBlock(stats, incomingDamage) {
      if (!stats.canBlock) return incomingDamage;
      const blockChance = Math.floor(Math.random() * (stats.blockMax - stats.blockMin + 1)) + stats.blockMin;
      if (Math.random() * 100 < blockChance) {
        const reducePerc = Math.floor(Math.random() * (stats.reduceMax - stats.reduceMin + 1)) + stats.reduceMin;
        return Math.max(1, Math.floor(incomingDamage * (1 - reducePerc / 100)));
      }
      return incomingDamage;
    }

    function applyBattleEffects(entity, effects) {
      let totalEffectDamage = 0;
      for (const [effect, data] of Object.entries(effects)) {
        if (data.duration > 0) {
          totalEffectDamage += data.damage;
          data.duration--;
        } else {
          delete effects[effect];
        }
      }
      return totalEffectDamage;
    }

    function resolveBattleRound() {
      // Apply effects first
      const playerEffectDmg = applyBattleEffects(player, currentBattle.playerEffects);
      const monsterEffectDmg = applyBattleEffects(currentBattle.monster, currentBattle.monsterEffects);
      
      if (playerEffectDmg > 0) {
        currentBattle.monster.hp -= playerEffectDmg;
      }
      if (monsterEffectDmg > 0) {
        player.hp -= monsterEffectDmg;
      }

      if (currentBattle.monster.hp <= 0) {
        // Monster defeated
        for (const [res, amount] of Object.entries(currentBattle.monster.drops || {})) {
          player.resources[res] = (player.resources[res] || 0) + amount;
        }
        
        // Update quests
        const monsterBaseName = currentBattle.monster.name.split(' ')[0].toLowerCase();
        for (const quest of Object.values(player.quests)) {
          if (!quest.completed && quest.target === monsterBaseName) {
            quest.current++;
            if (quest.current >= quest.count) {
              alert(`Quest "${quest.name}" ready to complete!`);
            }
          }
        }
        
        alert("Monster defeated! +10 üíé");
        player.diamonds += 10;
        endBattle();
        return;
      }
      
      if (player.hp <= 0) {
        player.hp = 1;
        alert("Defeated! Lost 5 üíé");
        player.diamonds = Math.max(0, player.diamonds - 5);
        endBattle();
        return;
      }

      // Monster chooses action
      if (currentBattle.monster.spells.length > 0 && currentBattle.monster.mana >= 3 && Math.random() > 0.5) {
        const randomSpell = currentBattle.monster.spells[Math.floor(Math.random() * currentBattle.monster.spells.length)];
        currentBattle.monsterAction = { spell: randomSpell };
        currentBattle.monster.mana -= 3;
      } else {
        currentBattle.monsterAction = {
          attack: ['head', 'body', 'legs'][Math.floor(Math.random() * 3)],
          defense: ['head', 'body', 'legs'][Math.floor(Math.random() * 3)]
        };
      }

      let log = "";

      // Player action
      if (currentBattle.playerAction.spell) {
        const spellId = currentBattle.playerAction.spell;
        let foundSpell = null;
        
        for (const school of Object.values(SPELLS)) {
          for (const spell of school) {
            if (spell.id === spellId) {
              foundSpell = spell;
              break;
            }
          }
          if (foundSpell) break;
        }
        
        if (foundSpell && player.mana >= foundSpell.mana) {
          player.mana -= foundSpell.mana;
          
          if (foundSpell.effect && typeof foundSpell.effect === 'function') {
            foundSpell.effect(player, currentBattle.monster);
            log += `Casted ${foundSpell.name}!\n`;
          } else if (foundSpell.damage) {
            let dmg = foundSpell.damage;
            // Magic cannot be fully blocked, but reduced if defended
            if (currentBattle.monsterAction.defense === currentBattle.playerAction.attack) {
              dmg = Math.floor(dmg * 0.5);
            }
            currentBattle.monster.hp -= dmg;
            log += `Casted ${foundSpell.name} for ${dmg} damage!\n`;
            
            if (foundSpell.effect && typeof foundSpell.effect === 'string') {
              currentBattle.monsterEffects[foundSpell.effect] = {
                damage: foundSpell.effectDamage,
                duration: foundSpell.effectDuration
              };
            }
          }
        } else {
          log += "Not enough mana!\n";
        }
      } else {
        // Physical attack
        const stats = calculateStats(player);
        let playerDmg = calculateDamage(stats.totalMinDmg, stats.totalMaxDmg, stats.totalCrit);
        
        // Critical hit logic
        const isCrit = playerDmg > Math.floor((stats.totalMinDmg + stats.totalMaxDmg) / 2) * 1.4;
        if (isCrit) {
          // Crit deals 50% damage even if defended
          if (currentBattle.monsterAction.defense === currentBattle.playerAction.attack) {
            playerDmg = Math.floor(playerDmg * 0.5);
          }
          // Shield can still reduce crit damage
          const monsterStats = calculateStats(currentBattle.monster);
          playerDmg = applyBlock(monsterStats, playerDmg);
        } else {
          // Normal hit
          if (currentBattle.monsterAction.defense === currentBattle.playerAction.attack) {
            playerDmg = 0; // Fully blocked
          } else {
            const monsterStats = calculateStats(currentBattle.monster);
            playerDmg = applyBlock(monsterStats, playerDmg);
          }
        }
        
        currentBattle.monster.hp -= playerDmg;
        log += `Attacked ${currentBattle.playerAction.attack} ‚Üí dealt ${playerDmg} damage!\n`;
      }

      // Monster action
      if (currentBattle.monsterAction.spell) {
        log += `Monster casts ${currentBattle.monsterAction.spell}!\n`;
        let dmg = 6; // Base spell damage
        // Magic cannot be blocked by shield, but reduced if defended
        if (currentBattle.playerAction.defense === currentBattle.monsterAction.attack) {
          dmg = Math.floor(dmg * 0.5);
        }
        player.hp -= dmg;
        log += `Took ${dmg} magical damage!`;
      } else {
        // Physical attack
        let monsterDmg = currentBattle.monster.damage;
        if (currentBattle.monsterAction.attack === currentBattle.playerAction.defense) {
          monsterDmg = 0; // Fully blocked
        } else {
          const playerStats = calculateStats(player);
          monsterDmg = applyBlock(playerStats, monsterDmg);
        }
        player.hp -= monsterDmg;
        log += `Monster attacked ${currentBattle.monsterAction.attack} ‚Üí dealt ${monsterDmg} damage!`;
      }

      // Reduce cooldowns
      for (const spell in player.spellCooldowns) {
        if (player.spellCooldowns[spell] > 0) {
          player.spellCooldowns[spell]--;
        }
      }

      if (currentBattle.monster.hp <= 0) {
        log += "\n\nMonster defeated! +10 üíé";
        player.diamonds += 10;
        endBattle();
      } else if (player.hp <= 0) {
        player.hp = 1;
        log += "\n\nYou were defeated! Lost 5 üíé";
        player.diamonds = Math.max(0, player.diamonds - 5);
        endBattle();
      } else {
        log += `\n\nRound ${currentBattle.round} complete.`;
        currentBattle.round++;
        alert(log);
        startBattleTimer();
      }
    }

    function endBattle() {
      clearInterval(battleTimer);
      currentBattle = null;
      document.getElementById('battle-ui').style.display = 'none';
      saveToLocalStorage();
    }

    // === TOURNAMENT SYSTEM ===
    let tournamentSystem = {
      active: false,
      participants: [],
      matches: [],
      startTime: null,
      type: null
    };

    function checkTournament() {
      const now = new Date();
      const hours = now.getHours() + (now.getTimezoneOffset() / 60) + 3;
      
      if (hours >= 20 && hours < 21) {
        document.getElementById('tournament-ui').style.display = 'block';
        document.getElementById('tournament-info').innerHTML = `
          <p>Tournament active!</p>
          <p>Participants: ${tournamentSystem.participants.length}</p>
          <p>Type: Choose below</p>
        `;
      } else {
        alert("Tournaments daily at 20:00 MSK.\n‚Ä¢ Tavern: no weapons, magic allowed\n‚Ä¢ Arena: full gear, NFT prize for winner");
      }
    }

    function registerForTournament(tournamentType) {
      const now = new Date();
      const hours = now.getHours() + (now.getTimezoneOffset() / 60) + 3;
      
      if (hours >= 20 && hours < 21) {
        if (tournamentType === 'tavern') {
          // Check tavern restrictions
          if (player.inventory.mainHand && WEAPONS[player.inventory.mainHand]?.type !== 'staff') {
            alert("Tavern tournament requires no weapons! Only magic permitted.");
            return;
          }
        }
        
        if (!tournamentSystem.participants.find(p => p.id === player.id)) {
          tournamentSystem.participants.push({ ...player });
          alert(`Registered for ${tournamentType} tournament!`);
          saveToLocalStorage();
        } else {
          alert("Already registered!");
        }
      } else {
        alert("Registration only at 20:00 MSK!");
      }
    }

    function closeTournamentUI() {
      document.getElementById('tournament-ui').style.display = 'none';
    }

    function viewTournamentMatches() {
      let html = `<h4>Current Matches:</h4>`;
      tournamentSystem.matches.forEach((match, index) => {
        if (match.rested) {
          html += `<p>Player ${match.player1.name} rests (+10% HP)</p>`;
        } else {
          html += `<p>Match ${index + 1}: ${match.player1.name} vs ${match.player2?.name || 'Bye'}</p>`;
        }
      });
      document.getElementById('tournament-info').innerHTML = html;
    }

    // === SAVE PLAYER ===
    function render() {
      const stats = calculateStats(player);
      document.getElementById('player-info').innerHTML = `
        ${player.name} (Lvl ${player.level})<br>
        HP: ${player.hp}/${player.max_hp} | Mana: ${player.mana}/${player.max_mana + stats.manaBonus}<br>
        Damage: ${stats.totalMinDmg}-${stats.totalMaxDmg} | Crit: ${stats.totalCrit}%<br>
        Block: ${stats.canBlock ? `${stats.blockMin}-${stats.blockMax}% chance, reduces ${stats.reduceMin}-${stats.reduceMax}% damage` : "None"}<br>
        Magic School: ${stats.magicSchool || "None"}<br>
        Diamonds: üíé${player.diamonds} | Gold: ${player.gold}<br>
        NFT Sacrifices: ${player.nftSacrifices}
      `;
    }

    // Initialize
    initGame();
  </script>
</body>
</html>